<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>What Made Lisp Different</title>
	<style>body,html{margin:0;padding:0}body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;padding:32px 16px 32px;font-size:16px;line-height:1.5}@media (min-width:40em){body{font-size:20px;padding:64px 32px 64px}}@media (min-width:52em){body{font-size:24px;padding:60px 64px 128px}}footer{color:#ccc;margin-top:5em}section{max-width:864px}h1{font-size:32px;line-height:1.25;margin:.5em 0 0}@media (min-width:40em){h1{font-size:48px}}@media (min-width:52em){h1{font-size:64px}}h2{font-size:28px;line-height:1.25;margin:.5em 0 0}@media (min-width:40em){h2{font-size:42px}}@media (min-width:52em){h2{font-size:56px}}h3{font-size:16px;line-height:1.25;margin:2em 0 0}@media (min-width:40em){h3{font-size:24px}}@media (min-width:52em){h3{font-size:32px}}hr{margin:3em 0;max-width:864px;border:0;border-bottom:1px solid #f6f6f6}@media (min-width:40em){hr{margin:2em 0}}.logo{display:inline-block;vertical-align:-1px;margin-left:.2em}a{text-decoration:none;color:#0075ff;background:0 100%/100% 1px repeat-x;background-image:linear-gradient(rgba(0,117,255,.13),rgba(0,117,255,.13))}@media (min-width:40em){a{background-size:100% 2px}}a:hover{background-image:linear-gradient(rgba(0,117,255,1),rgba(0,117,255,1))}.logo-link{white-space:nowrap}ul{margin-top:1em;padding-left:2em;list-style:none}ul li+li{margin-top:.25em}.buzzwords{color:#aaa;font-size:.8em}address{font-size:.7em;font-style:normal}</style></head>
	<body>
		<section>
			<h1>What Made Lisp Different</h1>
			<div>
					<span>
							<a href="http://www.paulgraham.com/diff.html">Оригинал</a>
							<a href="https://habr.com/ru/post/476994/">Перевод</a>
					</span>
				</div>
		</section>
			<p>
			Декабрь 2001 (обновлено в мае 2002)
			</p>
			<p>
			(Эта статья появилась в ответ на некоторые вопросы в списке рассылки <a href="http://ll1.mit.edu/">LL1</a>. Теперь она включена в статью <a href="http://www.paulgraham.com/icad.html">Revenge of the Nerds</a>).
			</p>
			<p>
			Когда Маккарти разработал Lisp в конце 1950-х, он радикально отличался от существующих языков, самым главным из которых был <a href="http://www.paulgraham.com/history.html">Fortran</a>.
			</p>
			<p>
			Lisp воплотил девять новых идей:
			</p>
			<br>
			<p>
			<b>1. Условные высказывания.</b> Условные высказывания это if-then-else конструкция. Сейчас мы воспринимаем их как должное. Они были <a href="http://www-formal.stanford.edu/jmc/history/lisp/node2.html">изобретены</a> Маккарти во время разработки Lisp. (Fortran в то время имел только goto-утверждения, тесно связанные с инструкцией ветвления на лежащем в основе железе.) Маккарти, будучи в комитете по Algol, внёс условные высказывания в Algol, откуда они распространились на другие языки.
			</p>
			<p>
			<b>2. Функциональные типы.</b> В Lisp'е функции это объекты первого класса — они являются типом данных, также как числа, строки и т.д., и имеют буквальное представление, могут храниться в переменных, могут быть переданы как аргументы, и.т.д.
			</p>
			<p>
			<b>3. Рекурсия.</b> Рекурсия, конечно, существовала как математическая концепция до Lisp'а, но Lisp был первым языком программирования поддерживающим её. (Это возможно подразумевается в создании функций как объектов первого класса.)
			</p>
			<p>
			<b>4. Новая концепция переменных.</b> В Lisp'е все переменные являются эффективными указателями. Значения — это то, что есть у типов, а не у переменных, а присвоение или связывание переменных означает копирование указателей, а не того, на что они указывают.
			</p>
			<p>
			<b>5. Сборка мусора.</b>
			</p>
			<p>
			<b>6. Программы состоят из выражений.</b> Программы на Lisp'е это деревья выражений, каждое из которых возвращает значение. (Некоторые Lisp-выражения могут возвращать множественные значения.) Это входит в контраст с Fortran'ом и с множеством других успешных языков, которые различают «выражения» и «утверждения».
			</p>
			<p>
			Было естественным иметь такое различие в Fortran'е, потому что язык был линейно-ориентированным (не удивительно для языка, в котором форматом ввода была перфокарта). Вы не могли иметь вложенные утверждения. И пока вам требовались математические выражения для работы, не было смысла в том, чтобы заставлять что-нибудь ещё возвращать значение, потому что могло не быть чего-то, что ожидало возврата.
			</p>
			<p>
			Ограничения были сняты с появлением блочно-структурированных языков, но к тому моменту было уже слишком поздно. Различие между выражениями и утверждениями уже закрепилось. Оно перешло от Fortran'а к Algol'у и далее к их потомкам.
			</p>
			<p>
			Когда язык сделан полностью из выражений, вы можете составлять выражения как пожелаете. Вы можете написать либо (используя синтаксис <a href="http://www.paulgraham.com/arc.html">Arc</a>)
			</p>
			<ul>
				<li>
			(if foo (= x 1) (= x 2))
				</li>
			</ul>
			<p>
			либо
			</p>
			<ul>
				<li>
			(= x (if foo 1 2))
				</li>
			</ul>
			<p>
			<b>7. Символьный тип.</b> Символы отличаются от строк, в этом случае вы можете проверить на равенство, сравнив указатели.
			</p>
			<p>
			<b>8. Нотация для кода</b> с использованием деревьев из символов.
			</p>
			<p>
			<b>9. Весь язык всегда доступен.</b> Нет явного различия между временем чтения, временем компиляции и временем выполнения. Вы можете компилировать или запускать код во время чтения, или читать или запускать кода пока компилируете, или читать или компилировать код во время выполнения.
			</p>
			<p>
			Запуск кода во время чтения позволяет пользователям перепрограммировать синтаксис Lisp'а; запуск кода во время компиляции это основа для макросов; компилирование во время выполнения это основа использования Lisp'ов как языка расширения в таких программах как Emacs; и наконец, чтение во время выполнения позволяет программам взаимодействовать, используя s-выражения, идея, недавно переизобретённая в XML.
			</p>
			<br>
			<p>
			Когда Lisp был только изобретён, все эти идеи были сильно далеки от обычных практик программирования, которые диктовались железом, доступным в конце 1950-х.
			</p>
			<p>
			Со временем язык по умолчанию, воплощённый в успехе популярных языков, постепенно эволюционировал в сторону Lisp. Пункты 1-5 теперь широко распространены. Пункт 6 начинает появляться в мэйнстриме. В Python'е в некотором виде есть пункт 7, хотя подходящего синтаксиса нет. Пункт 8, который (с пунктом 9) делает возможным макросы в Lisp'е, до сих пор есть только в Lisp'е, возможно потому что (а) он требует эти скобки или чего-то столь же плохого, и (б) если вы добавите это последнее увеличение мощности, то больше не сможете утверждать, что изобрели новый язык, а только лишь разработали новый диалект Lisp'а; -)
			</p>
			<p>
			Хотя это полезно для современных программистов, странно описывать Lisp с точки зрения его отличия от случайных приёмов, принятых в других языках. Возможно это не то, о чём думал Маккарти. Lisp не был спроектирован, чтобы исправить ошибки Fortran'а; он появился скорее как побочный продукт попытки <a href="http://www.paulgraham.com/rootsoflisp.html">аксиоматизировать вычисления</a>.
			</p>
			<footer>
				<nav>
				<div style="margin: 0 auto; width: 450px; font-size: 15px">
					<span>
							<a href="/">Главная</a>
							<a href="/paulgraham">Пол Грэм</a>
							<a href="/sivers">Дерек Сиверc</a>
							<a href="/donation">Донаты</a>
					</span>
				</div>
				</nav>
				<p>Будь верен себе</p>
				<address>
					<p>Иван Капцов, Планета Земля, Измерение C-137</p>
				</address>
			</footer>
	</body>
</html>