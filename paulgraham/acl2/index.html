<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Chapter 2 of Ansi Common Lisp</title>
	<style>body,html{margin:0;padding:0}body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;padding:32px 16px 32px;font-size:16px;line-height:1.5}@media (min-width:40em){body{font-size:20px;padding:64px 32px 64px}}@media (min-width:52em){body{font-size:24px;padding:60px 64px 128px}}footer{color:#ccc;margin-top:5em}section{max-width:864px}h1{font-size:32px;line-height:1.25;margin:.5em 0 0}@media (min-width:40em){h1{font-size:48px}}@media (min-width:52em){h1{font-size:64px}}h2{font-size:28px;line-height:1.25;margin:.5em 0 0}@media (min-width:40em){h2{font-size:42px}}@media (min-width:52em){h2{font-size:56px}}h3{font-size:16px;line-height:1.25;margin:2em 0 0}@media (min-width:40em){h3{font-size:24px}}@media (min-width:52em){h3{font-size:32px}}hr{margin:3em 0;max-width:864px;border:0;border-bottom:1px solid #f6f6f6}@media (min-width:40em){hr{margin:2em 0}}.logo{display:inline-block;vertical-align:-1px;margin-left:.2em}a{text-decoration:none;color:#0075ff;background:0 100%/100% 1px repeat-x;background-image:linear-gradient(rgba(0,117,255,.13),rgba(0,117,255,.13))}@media (min-width:40em){a{background-size:100% 2px}}a:hover{background-image:linear-gradient(rgba(0,117,255,1),rgba(0,117,255,1))}.logo-link{white-space:nowrap}ul{margin-top:1em;padding-left:2em;list-style:none}ul li+li{margin-top:.25em}.buzzwords{color:#aaa;font-size:.8em}address{font-size:.7em;font-style:normal}</style></head>
	<body>
		<section>
			<h1>Chapter 2 of Ansi Common Lisp</h1>
			<div>
					<span>
							<a href="https://sep.yimg.com/ty/cdn/paulgraham/acl2.txt?t=1651069852&">Оригинал</a>
					</span>
				</div>
		</section>
			<p>
			(Это глава 2 из книги ANSI Common Lisp, автор Пол Грэм. Copyright 1995, Prentice-Hall.)
			</p>
			<p>
			<b>Добро пожаловать в Lisp</b>
			</p>
			<p>
			Цель этой главы - как можно скорее начать программировать. К концу главы вы будете знать достаточно языка Common Lisp, чтобы начать писать программы.
			</p>
			<p>
			<b>2.1 Форма</b>
			</p>
			<p>
			Для Lisp особенно верно то, что вы изучаете его, используя его, потому что Lisp - это интерактивный язык. Любая система Lisp включает в себя интерактивный интерфейс, называемый верхним уровнем. Вы вводите выражения Lisp в toplevel, а система отображает их значения.
			</p>
			<p>
			Обычно Lisp выводит подсказку, чтобы сообщить вам, что он ждет, пока вы что-то напечатаете. Многие реализации Common Lisp используют > в качестве подсказки уровня. Это то, что мы будем использовать здесь.
			</p>
			<p>
			Одним из простейших видов выражений Lisp является целое число. Если мы введем 1 после подсказки,
			</p>
			<pre>
			> 1
			1
			> 
			</pre>
			<p>
			система выведет его значение, а затем еще один запрос, чтобы сказать, что она готова к дальнейшим действиям.
			</p>
			<p>
			В данном случае выведенное значение совпадает с тем, что мы набрали. Число, подобное 1, как говорят, оценивает само себя. Жизнь становится интереснее, когда мы вводим выражения, для оценки которых требуется определенная работа. Например, если мы хотим сложить два числа, мы вводим что-то вроде:
			</p>
			<pre>
			> (+ 2 3)
			5	
			</pre>	
			<p>
			В выражении (+ 2 3) символ + называется оператором, а числа 2 и 3 - аргументами.
			</p>
			<p>
			В повседневной жизни мы бы записали это выражение как 2 + 3, но в Lisp мы ставим сначала оператор +, затем аргументы, а все выражение заключаем в круглые скобки: (+ 2 3). Это называется префиксной нотацией, потому что оператор стоит первым. Поначалу это может показаться странным способом записи выражений, но на самом деле эта нотация - одна из лучших в Lisp.
			</p>
			<p>
			Например, если мы хотим сложить три числа, то в обычной нотации нам придется дважды использовать +,
			</p>
			<pre>
			2 + 3 + 4
			</pre>
			<p>
			в то время как в Lisp мы просто добавляем еще один аргумент:
			</p>
			<pre>
			(+ 2 3 4)
			</pre>
			<p>
			Как мы обычно используем +, он должен иметь ровно два аргумента: один слева и один справа. Гибкость префиксной нотации означает, что в Lisp + может принимать любое количество аргументов, в том числе и ни одного:
			</p>
			<pre>
			> (+)
			0
			> (+ 2)
			2
			> (+ 2 3)
			5
			> (+ 2 3 4)
			9
			> (+ 2 3 4 5)
			14	
			</pre>
			<p>
			Поскольку операторы могут принимать различное количество аргументов, нам нужны круглые скобки, чтобы показать, где начинается и заканчивается выражение.
			</p>
			<p>
			Выражения могут быть вложенными. То есть аргументы в выражении могут сами быть сложными выражениями:
			</p>
			<pre>			
			> (/ (- 7 1) (- 4 2))
			3
			</pre>
			<p>
			В английском языке это семь минус один, деленное на четыре минус два.
			</p>
			<p>
			Еще одна прелесть нотации Lisp: это все, что есть. Все выражения Lisp - это либо атомы, такие как 1, либо списки, состоящие из нуля или более выражений, заключенных в круглые скобки. Это допустимые выражения Lisp:
			</p>
			<pre>
			2   (+ 2 3)   (+ 2 3 4)   (/ (- 7 1) (- 4 2))
			</pre>
			<p>
			Как мы увидим, весь код Lisp имеет такую форму. Язык типа C имеет более сложный синтаксис: арифметические выражения используют инфиксную нотацию; вызовы функций используют своего рода префиксную нотацию, с аргументами, разделенными запятыми; выражения разделены точками с запятой; блоки кода разделены фигурными скобками. В Lisp мы используем единую нотацию для выражения всех этих идей.
			</p>
			<p>
			<b>2.2 Оценка</b>
			</p>
			<p>
			В предыдущем разделе мы вводили выражения на верхнем уровне, а Lisp отображал их значения. В этом разделе мы подробнее рассмотрим, как оцениваются выражения.
			</p>
			<p>
			В Lisp + - это функция, а выражение типа (+ 2 3) - это вызов функции. Когда Lisp оценивает вызов функции, он делает это в два этапа:
			</p>
			<ul>
				<li>
			  1. Сначала оцениваются аргументы, слева направо. В данном случае каждый аргумент оценивается сам по себе, поэтому значения аргументов равны 2 и 3 соответственно.
			  	</li>
			  	<li>
			  2. Значения аргументов передаются в функцию, названную оператором. В данном случае это функция +, которая возвращает 5.
			  	</li>
			</ul>
			<p>
			Если какие-либо аргументы сами являются вызовами функций, то они оцениваются по тем же правилам. Поэтому, когда оценивается (/ (- 7 1) (- 4 2)), происходит следующее:
			</p>
			<ul>
				<li>
			  1. Lisp оценивает (- 7 1): 7 оценивается в 7, а 1 - в 1. Эти значения передаются в функцию -, которая возвращает 6.
			  	</li>
			  	<li>
			  2. Lisp оценивает (- 4 2): 4 оценивается в 4 и 2 оценивается в 2. Эти значения передаются в функцию -, которая возвращает 2.
			  	</li>
			  	<li>
			  3. Значения 6 и 2 передаются в функцию /, которая возвращает 3.
			  	</li>
			</ul>
			<p>
			Не все операторы в Common Lisp являются функциями, но большинство из них. И вызовы функций всегда оцениваются таким образом. Аргумент оценивается слева направо, а его значения передаются в функцию, которая возвращает значение выражения в целом. Это называется правилом оценки в Common Lisp.
			</p>
			<p>
			Один из операторов, который не соответствует правилу оценки Common Lisp, - это оператор quote. Оператор quote - это специальный оператор, то есть у него есть свое собственное правило оценки. И это правило гласит: ничего не делать. Оператор quote принимает единственный аргумент и просто возвращает его дословно:
			</p>
			<pre>
			> (quote (+ 3 5))
			(+ 3 5)
			</pre>
			<p>
			Для удобства Common Lisp определяет ' как сокращение для цитаты. Вы можете получить эффект вызова quote, добавив символ ' перед любым выражением:
			</p>
			<pre>
			> '(+ 3 5)
			(+ 3 5)
			</pre>
			<p>
			Гораздо чаще используется сокращение, чем записывается все выражение в кавычках.
			</p>
			<p>
			Lisp предоставляет кавычки как способ защиты выражений от оценки. В следующем разделе будет рассказано, как такая защита может быть полезна.
			</p>
			<p>
			---------------------------------------------------------------------
			</p>
			<p>			
			<b>Выход из затруднительного положения</b>
			</p>
			<p>
			Если вы введете что-то, что Lisp не сможет понять, он выдаст сообщение об ошибке и переведет вас в версию уровня toplevel, называемую циклом прерывания. Петля прерывания дает опытным программистам шанс разобраться, что вызвало ошибку, но изначально единственное, что вы захотите сделать в петле прерывания, это выйти из нее. Что нужно набрать, чтобы вернуться на верхний уровень, зависит от вашей реализации Common Lisp. В этой гипотетической реализации это делает :abort:
			</p>
			<pre>
			> (/ 1 0)
			Error: Division by zero.
			       Options: :abort, :backtrace
			>> :abort
			>
			</pre>
			<p>
			В Приложении А показано, как отлаживать программы на Lisp, и приведены примеры некоторых наиболее распространенных ошибок.
			</p>
			<p>
			---------------------------------------------------------------------
			</p>
			<p>
			<b>2.3 Данные</b>
			</p>
			<p>
			Lisp предлагает все типы данных, которые встречаются в большинстве других языков, а также несколько других, которые нам не знакомы. Одним из типов данных, который мы уже использовали, является целое число, которое записывается как ряд цифр: 256. Другой тип данных, который Lisp имеет с большинством других языков, - это строка, которая представляется в виде серии символов, окруженных двойными кавычками: "ora et labora". И целое число, и строка оцениваются сами по себе.
			</p>
			<p>
			Два типа данных Lisp, которые мы не часто встречаем в других языках, - это символы и списки. Символы - это слова.Обычно они преобразуются в верхний регистр, независимо от того, как вы их набираете:
			</p>
			<pre>
			> 'Artichoke
			ARTICHOKE
			</pre>
			<p>
			Символы (обычно) не оцениваются сами по себе, поэтому, если вы хотите сослаться на символ, вы должны заключить его в кавычки, как указано выше.
			</p>
			<p>
			Списки представляются как ноль или более элементов, заключенных в круглые скобки. Элементы могут быть любого типа, включая списки. Списки нужно заключать в кавычки, иначе Lisp примет их за вызовы функций:
			</p>
			<pre>
			> '(my 3 "Sons")
			(MY 3 "Sons")
			> '(the list (a b c) has 3 elements)
			(THE LIST (A B C) HAS 3 ELEMENTS)
			</pre>
			<p>
			Обратите внимание, что одна кавычка защищает все выражение, включая выражения внутри него.
			</p>
			<p>
			Вы можете строить списки, вызывая функцию list. Поскольку list - это функция, ее аргументы оцениваются. Здесь мы видим вызов + внутри вызова list:
			</p>
			<pre>
			> (list 'my (+ 2 1) "Sons")
			(MY 3 "Sons")
			</pre>
			<p>
			Теперь мы можем оценить одну из самых замечательных особенностей Lisp. Программы на Lisp выражаются в виде списков. Если аргументы гибкости и элегантности не убедили вас в том, что нотация Lisp является ценным инструментом, то этот пункт должен убедить вас. Это означает, что программы на Lisp могут генерировать код на Lisp. Программисты на Lisp могут (и часто так и делают) писать программы, которые пишут за них их программы.
			</p>
			<p>
			Такие программы не рассматриваются до главы 10, но даже на этом этапе важно понимать связь между выражением и списками, хотя бы для того, чтобы не запутаться в ней. Вот почему нам нужна кавычка. Если список заключен в кавычки, то оценка возвращает сам список; если список не заключен в кавычки, то список рассматривается как код, и оценка возвращает его значение:
			</p>
			<pre>
			> (list '(+ 2 1) (+ 2 1))
			((+ 2 1) 3)
			</pre>
			<p>
			Здесь первый аргумент заключен в кавычки, поэтому получается список. Второй аргумент не заключен в кавычки и рассматривается как вызов функции, давая число.
			</p>
			<p>
			В Common Lisp есть два способа представления пустого списка. Вы можете представить его в виде пары круглых скобок, между которыми ничего нет, или использовать символ nil. Не имеет значения, каким способом вы запишете пустой список, но он будет отображаться как nil:
			</p>
			<pre>
			> ()
			NIL
			> nil
			NIL
			</pre>
			<p>
			Вам не нужно заключать nil в кавычки (хотя это не помешает), потому что nil оценивает сам себя.
			</p>
			<p>
			<b>2.4 Операции со списками</b>
			</p>
			<p>
			Функция cons строит списки. Если ее второй аргумент - список, она возвращает новый список с первым аргументом, добавленным в начало:
			</p>
			<pre>
			> (cons 'a '(b c d))
			(A B C D)
			</pre>
			<p>
			Мы можем строить списки, объединяя новые элементы в пустой список. Функция list, которую мы рассматривали в предыдущем разделе, - это просто более удобный способ объединения нескольких элементов в nil:
			</p>
			<pre>
			> (cons 'a (cons 'b nil))
			(A B)
			> (list 'a 'b)
			(A B)
			</pre>
			<p>
			Примитивными функциями для извлечения элементов списков являются car и cdr. [1] Car списка - это первый элемент, а cdr - все, что находится после первого элемента:
			</p>
			<pre>
			> (car '(a b c))
			A
			> (cdr '(a b c))
			(B C)
			</pre>
			<p>
			Вы можете использовать комбинации car и cdr для получения любого элемента списка. Если вы хотите получить третий элемент, вы можете сказать:
			</p>
			<pre>
			> (car (cdr (cdr '(a b c d))))
			C
			</pre>
			<p>
			Однако вы можете сделать то же самое более простым способом, вызвав third:
			</p>
			<pre>
			> (third '(a b c d))
			C
			</pre>
			<p>
			<b>2.5 Истина</b>
			</p>
			<p>
			В языке Common Lisp символ t является стандартным представлением истины. Как и nil, t оценивает сам себя. Функция listp возвращает true, если ее аргумент является списком:
			</p>
			<pre>
			> (listp '(a b c))
			T
			</pre>
			<p>
			Функция, возвращаемое значение которой можно интерпретировать как истину или ложь, называется предикатом. Предикаты Common Lisp часто имеют имена, заканчивающиеся на p.
			</p>
			<p>
			Ложность в Common Lisp представлена nil, пустым списком. Если мы дадим listp аргумент, который не является списком, он вернет nil:
			</p>
			<pre>
			> (listp 27)
			NIL
			</pre>
			<p>
			Поскольку nil играет две роли в Common Lisp, функция null, которая возвращает true пустого списка,
			</p>
			<pre>
			> (null nil)
			T
			</pre>
			<p>
			и функция not, которая возвращает true, если ее аргумент false,
			</p>
			<pre>
			> (not nil)
			T
			</pre>
			<p>
			делают точно то же самое.
			</p>
			<p>
			Простейшим условным выражением в Common Lisp является if. Обычно он принимает три аргумента: тестовое выражение, выражение then и выражение else. Оценивается тестовое выражение. Если оно возвращает true, то оценивается выражение then и возвращается его значение. Если тестовое выражение возвращает false, то оценивается выражение else и возвращается его значение:
			</p>
			<pre>
			> (if (listp '(a b c))
			      (+ 1 2)
			      (+ 5 6))
			3
			> (if (listp 27)
			      (+ 1 2)
			      (+ 5 6))
			11
			</pre>
			<p>
			Как и quote, if - это специальный оператор. Он не может быть реализован как функция, потому что аргументы в вызове функции всегда оцениваются, а смысл if в том, что оценивается только один из двух последних аргументов.
			</p>
			<p>
			Последний аргумент if является необязательным. Если вы его опустите, то по умолчанию он будет равен nil:
			</p>
			<pre>
			> (if (listp 27) 
			      (+ 2 3))
			NIL
			</pre>
			<p>
			Хотя t является стандартным представлением истины, все, кроме nil, также считается истинным в логическом контексте:
			</p>
			<pre>
			> (if 27 1 2)
			1
			</pre>
			<p>
			Логические операторы and и or похожи на условные обозначения. Оба принимают любое количество аргументов, но оценивают только столько, сколько нужно, чтобы решить, что вернуть. Если все его аргументы истинны (то есть не nil), то and возвращает значение последнего из них:
			</p>
			<pre>
			> (and t (+ 1 2))
			3
			</pre>
			<p>
			Но если один из аргументов окажется ложным, ни один из последующих аргументов не будет оценен. Аналогично для оператора or, который останавливается, как только находит аргумент, который является истинным.
			</p>
			<p>			    
			Эти два оператора являются макросами. Как и специальные операторы, макросы могут обходить обычное правило оценки. В главе 10 объясняется, как писать собственные макросы.
			</p>
			<p>
			<b>2.6 Функции</b>
			</p>
			<p>
			Вы можете определять новые функции с помощью функции defun. Обычно она принимает три или более аргументов: имя, список параметров и одно или несколько выражений, которые будут составлять тело функции. Вот как мы можем определить третью функцию:
			</p>
			<pre>
			> (defun our-third (x)
			    (car (cdr (cdr x))))
			OUR-THIRD
			</pre>
			<p>
			Первый аргумент говорит, что имя этой функции будет our-third. Второй аргумент, список (x), говорит, что функция будет принимать ровно один аргумент: x. Символ, используемый таким образом в качестве заполнителя, называется переменной. Когда переменная представляет собой аргумент функции, как это делает x, она также называется параметром.
			</p>
			<p>
			Остальная часть определения, (car (cdr (cdr x))), называется телом функции. Оно сообщает Lisp, что он должен сделать, чтобы вычислить возвращаемое значение функции. Таким образом, вызов функции our-third возвращает (car (cdr (cdr x))) для любого x, который мы передаем в качестве аргумента:
			</p>
			<pre>
			> (our-third '(a b c d))
			C
			</pre>
			<p>
			Теперь, когда мы познакомились с переменными, легче понять, что такое символы. Это имена переменных, существующие как самостоятельные объекты. Именно поэтому символы, как и списки, должны заключаться в кавычки. Список должен быть заключен в кавычки, потому что иначе он будет рассматриваться как код; символ должен быть заключен в кавычки, потому что иначе он будет рассматриваться как переменная.
			</p>
			<p>
			Определение функции можно рассматривать как обобщенную версию выражения Lisp. Следующее выражение проверяет, больше ли сумма 1 и 4, чем 3:
			</p>
			<pre>
			> (> (+ 1 4) 3)
			T
			</pre>
			<p>
			Заменив эти конкретные числа переменными, мы можем написать функцию, которая будет проверять, больше ли сумма любых двух чисел, чем третье:
			</p>
			<pre>
			> (defun sum-greater (x y z)
			    (> (+ x y) z))
			SUM-GREATER
			> (sum-greater 1 4 3)
			T
			</pre>
			<p>
			Lisp не делает различий между программой, процедурой и функцией. Функции используются для всего (и действительно, составляют большую часть самого языка). Если вы хотите считать одну из ваших функций главной, вы можете это сделать, но, как правило, вы сможете вызывать любую функцию с верхнего уровня. Помимо прочего, это означает, что вы сможете тестировать свои программы по частям по мере их написания.
			</p>
			<p>
			<b>2.7 Рекурсия</b>
			</p>
			<p>
			Функции, которые мы определили в предыдущем разделе, вызывали другие функции для выполнения за них некоторой работы. Например, sum-greater вызывала + и >. Функция может вызывать любую функцию, включая саму себя.
			</p>
			<p>
			Функция, которая вызывает саму себя, является рекурсивной. Функция-член Common Lisp проверяет, является ли что-то элементом списка. Вот упрощенная версия, определенная как рекурсивная функция:
			</p>
			<pre>
			(defun our-member (obj lst)
			  (if (null lst)
			      nil
			      (if (eql (car lst) obj)
			          lst
			          (our-member obj (cdr lst)))))
			</pre>
			<p>
			Предикат eql проверяет, являются ли два его аргумента одинаковыми; кроме этого, все в этом определении - это то, что мы уже видели раньше. Вот оно в действии:
			</p>
			<pre>
			> (our-member 'b '(a b c))
			(B C)
			> (our-member 'z '(a b c))
			NIL
			</pre>
			<p>
			Определение our-member соответствует следующему английскому описанию. Чтобы проверить, является ли объект obj членом списка lst, мы
			</p>
			<ul>
				<li>
			  1. Сначала проверяем, пуст ли lst. Если он пуст, то obj явно не является его членом, и мы закончили.
			  	</li>
			  	<li>
			  2. В противном случае, если obj является первым элементом lst, то он является его членом.
			  	</li>
			  	<li>
			  3. В противном случае obj является членом lst, только если он является членом остальных элементов lst.
			  	</li>
			</ul>
			<p>
			Когда вы хотите понять, как работает рекурсивная функция, вам может помочь перевод ее в описание такого рода.
			</p>
			<p>
			Многим людям поначалу трудно понять рекурсию. Во многом трудности возникают из-за использования ошибочной метафоры для функций. Существует тенденция рассматривать функцию как некую машину. Сырье поступает в качестве параметров; часть работы передается другим функциям; наконец, готовый продукт собирается и отправляется в качестве возвращаемого значения. Если мы используем эту метафору для функций, рекурсия становится парадоксом. Как машина может перепоручить работу самой себе?  Она и так уже занята.
			</p>
			<p>
			Лучшей метафорой для функции будет представление о ней как о процессе, через который человек проходит. Рекурсия естественна в процессе. Мы часто видим рекурсивные процессы в повседневной жизни. Например, предположим, что историк интересуется изменениями численности населения в истории Европы. Процесс изучения документа мог бы выглядеть следующим образом:
			</p>
			<ul>
				<li>
			  1. Получить копию документа.
			  	</li>
			  	<li>
			  2. Ищите информацию, касающуюся изменения численности населения.
			  	</li>
			  	<li>
			  3. Если в документе упоминаются какие-либо другие документы, которые могут быть полезны, изучите их.
			  	</li>
			</ul>
			<p>
			Этот процесс достаточно прост для понимания, однако он рекурсивен, поскольку третий шаг может повлечь за собой одно или несколько применений того же процесса.
			</p>
			<p>
			Поэтому не думайте о our-member как о машине, которая проверяет, есть ли что-то в списке. Вместо этого думайте о нем как о правилах определения того, находится ли что-то в списке. Если мы думаем о функциях в этом свете, парадокс рекурсии исчезает. [2]
			</p>
			<p>
			<b>2.8 Чтение Lisp</b>
			</p>
			<p>
			Псевдочлен, определенный в предыдущем разделе, заканчивается пятью круглыми скобками. Более сложные определения функций могут заканчиваться семью или восемью. Людей, которые только изучают Lisp, вид такого количества скобок обескураживает. Как читать, а тем более писать такой код? Как увидеть, какая скобка соответствует какой?
			</p>
			<p>
			Ответ заключается в том, что это и не нужно. Программисты Lisp читают и пишут код по отступам, а не по скобкам. Когда они пишут код, они позволяют текстовому редактору показать, какая скобка какой соответствует. Любой хороший редактор, особенно если он поставляется вместе с системой Lisp, должен уметь выполнять паренс-сопоставление. В таком редакторе, когда вы вводите скобку, редактор показывает, какая из них совпадает. Если в вашем редакторе нет функции сопоставления скобок, остановитесь сейчас и выясните, как ее сделать, потому что без нее практически невозможно писать код на Lisp.
			</p>
			<p>
			[В vi вы можете включить паренс-сопоставление с помощью :set sm. В Emacs хороший способ - M-x lisp-mode].
			</p>
			<p>
			В хорошем редакторе согласование скобок перестает быть проблемой при написании кода. А поскольку существуют универсальные соглашения для отступов в Lisp, это не является проблемой и при чтении кода. Поскольку все используют одни и те же соглашения, вы можете читать код по отступам и не обращать внимания на скобки.
			</p>
			<p>
			Любой хакер Lisp, каким бы опытным он ни был, затруднился бы прочитать определение our-member, если бы оно выглядело следующим образом:
			</p>
			<pre>
			(defun our-member (obj lst) (if (null lst) nil (if 
			(eql (car lst) obj) lst (our-member obj (cdr lst)))))
			</pre>
			<p>
			Но когда код правильно отделен отступом, проблем не возникает. Можно опустить большую часть скобок и все равно прочитать его:
			</p>
			<pre>
			defun our-member (obj lst)
			  if null lst
			     nil
			     if eql (car lst) obj
			        lst
			        our-member obj (cdr lst)
			</pre>
			<p>
			Действительно, это практичный подход, когда вы пишете код на бумаге. Позже, когда вы набираете его, вы можете воспользоваться преимуществами парен-сопоставления в редакторе.
			</p>
			<p>
			<b>2.9 Ввод и вывод</b>
			</p>
			<p>
			До сих пор мы выполняли ввод/вывод неявно, используя преимущества уровня toplevel. Для реальных интерактивных программ этого, скорее всего, будет недостаточно. В этом разделе мы рассмотрим несколько функций для ввода и вывода.
			</p>
			<p>
			Наиболее общей функцией вывода в Common Lisp является format. Она принимает два или более аргументов: первый указывает, куда должен быть выведен вывод, второй является шаблоном строки, а остальные аргументы обычно являются объектами, чьи печатные представления должны быть вставлены в шаблон. Вот типичный пример:
			</p>
			<pre>
			> (format t "~A plus ~A equals ~A.~%" 2 3 (+ 2 3))
			2 plus 3 equals 5.
			NIL
			</pre>
			<p>
			Обратите внимание, что здесь отображаются две вещи. Первая строка отображается форматом. Вторая строка - это значение, возвращенное вызовом format, которое отображается обычным образом на верхнем уровне. Как правило, функция типа format не вызывается непосредственно с уровня toplevel, а используется внутри программы, поэтому возвращаемое значение никогда не будет
			не видно.
			</p>
			<p>
			Первый аргумент format, t, указывает, что вывод должен быть отправлен в место по умолчанию. Как правило, это будет уровень toplevel. Второй аргумент - это строка, которая служит шаблоном для вывода. В этой строке каждый ~A указывает на позицию, которая должна быть заполнена, а ~% указывает на новую строку. Позиции заполняются значениями остальных аргументов по порядку.
			</p>
			<p>
			Стандартной функцией ввода является read. Если аргументы не заданы, она читает из места по умолчанию, которое обычно является верхним уровнем. Вот функция, которая запрашивает у пользователя ввод и возвращает все, что было введено:
			</p>
			<pre>
			(defun askem (string)
			  (format t "~A" string)
			  (read))
			</pre>
			<p>
			Он ведет себя следующим образом:
			</p>
			<pre>
			> (askem "How old are you? ")
			How old are you? 29
			29
			</pre>
			<p>
			Имейте в виду, что read будет ждать бесконечно долго, пока вы не напечатаете что-нибудь и (обычно) не нажмете кнопку return. Поэтому неразумно вызывать read без явной подсказки, иначе может создаться впечатление, что ваша программа застряла, а на самом деле она просто ждет ввода.
			</p>
			<p>
			Второе, что нужно знать о read, это то, что он очень мощный: read - это полноценный синтаксический анализатор Lisp. Он не просто считывает символы и возвращает их в виде строки. Он разбирает то, что читает, и возвращает объект Lisp, который получается в результате. В приведенном выше случае он вернул число.
			</p>
			<p>
			Короткое определение askem показывает то, чего мы раньше не видели в функциях. Ее тело содержит более одного выражения. Тело функции может содержать любое количество выражений. Когда функция будет вызвана, они будут оценены по порядку, и функция вернет значение последнего из них.
			</p>
			<p>
			Во всех предыдущих разделах мы придерживались так называемого "чистого" Lisp, то есть Lisp без побочных эффектов. Побочный эффект - это некоторое изменение состояния мира, которое происходит как следствие оценки выражения. Когда мы оцениваем чистое выражение Lisp, такое как (+ 1 2), никаких побочных эффектов нет; оно просто возвращает значение. Но когда мы вызываем format, он не только возвращает значение, но и что-то печатает. Это один из видов побочных эффектов.
			</p>
			<p>
			Когда мы пишем код без побочных эффектов, нет смысла определять функции с телами, состоящими более чем из одного выражения. Значение последнего выражения возвращается как значение функции, а значения всех предыдущих выражений отбрасываются. Если бы у таких выражений не было побочных эффектов, вы бы не смогли определить, потрудился ли Lisp оценить их вообще.
			</p>
			<p>
			<b>2.10 Переменные</b>
			</p>
			<p>
			Одним из наиболее часто используемых операторов в Common Lisp является let, который позволяет вводить новые локальные переменные:
			</p>
			<pre>
			> (let ((x 1) (y 2))
			    (+ x y))
			3
			</pre>
			<p>
			Выражение let состоит из двух частей. Сначала идет список инструкций для создания переменных, каждая из которых имеет вид (выражение переменной). Каждая переменная изначально будет установлена в значение соответствующего выражения. Так, в приведенном выше примере мы создаем две новые переменные, x и y, которые первоначально устанавливаются в значения 1 и 2 соответственно. Эти переменные действуют в теле let.
			</p>
			<p>
			После списка переменных и значений идет тело выражений, которые оцениваются по порядку. В данном случае только одно - вызов +. Значение последнего выражения возвращается как значение let. Вот пример более выборочной версии askem, написанной с использованием let:
			</p>
			<pre>
			(defun ask-number ()
			  (format t "Please enter a number. ")
			  (let ((val (read)))
			    (if (numberp val)
			        val
			        (ask-number))))
			</pre>
			<p>
			Эта функция создает переменную val для хранения объекта, возвращенного функцией read. Поскольку у нее есть управление этим объектом, функция может посмотреть, что вы ввели, прежде чем решить, возвращать его или нет. Как вы, наверное, догадались, numberp - это предикат, который проверяет, является ли его аргумент числом.
			</p>
			<p>
			Если значение, введенное пользователем, не является числом, ask-number вызывает саму себя. В результате получается функция, которая настаивает на получении числа:
			</p>
			<pre>
			> (ask-number)
			Please enter a number. a
			Please enter a number. (ho hum)
			Please enter a number. 52
			52
			</pre>
			<p>
			Переменные, подобные тем, которые мы видели до сих пор, называются локальными переменными. Они действительны только в определенном контексте. Существует другой вид переменных, называемый глобальной переменной, которая может быть видна везде.
			</p>
			<p>
			[На самом деле здесь существует различие между лексическими и специальными переменными, но мы не будем рассматривать этот вопрос до главы 6].
			</p>
			<p>
			Вы можете создать глобальную переменную, задав символ и значение параметру defparameter:
			</p>
			<pre>
			> (defparameter *glob* 99)
			*GLOB*
			</pre>
			<p>
			Такая переменная будет доступна везде, кроме выражений, создающих новую локальную переменную с тем же именем. Чтобы избежать случайного возникновения такой ситуации, принято давать глобальным переменным имена, начинающиеся и заканчивающиеся звездочками. Имя переменной, которую мы только что создали, будет звучать как "star-glob-star".
			</p>
			<p>
			Вы также можете определить глобальные константы, вызвав команду defconstant:
			</p>
			<pre>
			(defconstant limit (+ *glob* 1))
			</pre>
			<p>
			Нет необходимости давать константам отличительные имена, поскольку это приведет к ошибке, если кто-то использует такое же имя для переменной. Если вы хотите проверить, является ли некоторый символ именем глобальной переменной или константы, используйте boundp:
			</p>
			<pre>
			> (boundp '*glob*)
			T
			</pre>
			<p>
			<b>2.11 Присваивание</b>
			</p>
			<p>
			В Common Lisp наиболее общим оператором присваивания является setf. Мы можем использовать его для присваивания переменным любого типа:
			</p>
			<pre>
			> (setf *glob* 98)
			98
			> (let ((n 10))
			    (setf n 2)
			    n)
			2
			</pre>
			<p>
			Если первым аргументом setf является символ, который не является именем локальной переменной, он принимается за глобальную переменную:
			</p>
			<pre>
			> (setf x (list 'a 'b 'c))
			(A B C)
			</pre>
			<p>
			То есть, вы можете создавать глобальные переменные неявно, просто присваивая им значения. В исходных файлах, по крайней мере, лучше использовать явные параметры defparameters.
			</p>
			<p>
			Вы можете делать больше, чем просто присваивать значения переменным. Первым аргументом setf может быть как выражение, так и имя переменной. В таких случаях значение второго аргумента вставляется в то место, на которое ссылается первый:
			</p>
			<pre>
			> (setf (car x) 'n) 
			N
			> x
			(N B C)
			</pre>
			<p>
			Первым аргументом оператора setf может быть практически любое выражение, которое ссылается на определенное место. Все такие операторы помечены как "устанавливаемые" в Приложении D.
			</p>
			<p>
			Вы можете задать любое (четное) количество аргументов для setf. Выражение вида
			</p>
			<pre>
			(setf a b 
			      c d 
			      e f)
			</pre>
			<p>
			эквивалентно трем отдельным последовательным вызовам setf:
			</p>
			<pre>
			(setf a b)
			(setf c d)
			(setf e f)
			</pre>
			<p>
			<b>2.12 Функциональное программирование</b>
			</p>
			<p>
			Функциональное программирование означает написание программ, которые работают путем возврата значений, а не путем изменения вещей. Это доминирующая парадигма в Lisp. Большинство встроенных функций Lisp предназначены для вызова возвращаемых ими значений, а не для побочных эффектов.
			</p>
			<p>
			Функция remove, например, принимает объект и список и возвращает новый список, содержащий все, кроме этого объекта:
			</p>
			<pre>
			> (setf lst '(c a r a t))
			(C A R A T)
			> (remove 'a lst)
			(C R T)
			</pre>
			<p>
			Почему бы просто не сказать, что remove удаляет объект из списка?  Потому что это не то, что он делает. Исходный список после этого остается нетронутым:
			</p>
			<pre>
			> lst
			(C A R A T)
			</pre>
			<p>
			Что же делать, если вы действительно хотите удалить что-то из списка? В Lisp вы обычно делаете такие вещи, передавая список в качестве аргумента некоторой функции и используя setf с возвращаемым значением. Чтобы удалить все as из списка x, мы говорим:
			</p>
			<pre>
			(setf x (remove 'a x))
			</pre>
			<p>
			Функциональное программирование означает, по сути, отказ от setf и подобных ему вещей. На первый взгляд может быть трудно представить, как это вообще возможно, не говоря уже о желательности. Как можно строить программы, просто возвращая значения?
			</p>
			<p>
			Было бы неудобно полностью обойтись без побочных эффектов. Однако, читая дальше, вы можете с удивлением обнаружить, как мало их на самом деле нужно. И чем больше побочных эффектов вы оставите, тем лучше вам будет.
			</p>
			<p>
			Одним из важнейших преимуществ функционального программирования является возможность интерактивного тестирования. В чисто функциональном коде вы можете тестировать каждую функцию по мере ее написания. Если она возвращает ожидаемые значения, вы можете быть уверены в ее правильности. Эта уверенность в совокупности дает огромную разницу. Вы можете мгновенно вносить изменения в любое место программы. И это мгновенное решение позволяет создать совершенно новый стиль программирования, так же как телефон, по сравнению с письмами, позволил создать новый стиль общения.
			</p>
			<p>
			<b>2.13 Итерация</b>
			</p>
			<p>
			Когда мы хотим сделать что-то многократно, иногда естественнее использовать итерацию, чем рекурсию. Типичным случаем итерации является генерация какой-либо таблицы. Эта функция
			</p>
			<pre>
			(defun show-squares (start end)
			  (do ((i start (+ i 1)))
			      ((> i end) 'done)
			    (format t "~A ~A~%" i (* i i))))
			</pre>
			<p>
			выводит квадраты целых чисел от начала до конца:
			</p>
			<pre>
			> (show-squares 2 5)
			2 4
			3 9 
			4 16
			5 25
			DONE
			</pre>
			<p>
			Макрос do - это фундаментальный оператор итерации в Common Lisp. Как и let, do может создавать переменные, и первым аргументом является список спецификаций переменных. Каждый элемент этого списка может иметь вид
			</p>
			<pre>
			(переменная начальная обновить)
			</pre>
			<p>			
			где variable - символ, а initial и update - выражения. Изначально каждая переменная будет установлена в значение соответствующего initial; на каждой итерации она будет установлена в значение соответствующего update. Do в show-squares создает только одну переменную, i. На первой итерации i будет установлена в значение start, а на последующих итерациях ее значение будет увеличиваться на единицу.
			</p>
			<p>
			Вторым аргументом do должен быть список, содержащий одно или несколько выражений. Первое выражение используется для проверки того, должна ли итерация остановиться. В приведенном выше случае тестовым выражением является (> i end). Остальные выражения в этом списке будут оценены по порядку, когда итерация остановится, и значение последнего будет возвращено в качестве значения do. Таким образом, show-squares всегда будет возвращать done.
			</p>
			<p>
			Остальные аргументы do составляют тело цикла. Они будут оцениваться по порядку на каждой итерации. На каждой итерации обновляются переменные, затем оценивается тест на завершение, а затем (если тест не прошел) оценивается тело цикла.
			</p>
			<p>
			Для сравнения, вот рекурсивная версия show-squares:	
			</p>
			<pre>
			(defun show-squares (i end)
			  (if (> i end)
			      'done
			      (progn
			        (format t "~A ~A~%" i (* i i))
			        (show-squares (+ i 1) end))))
			</pre>
			<p>
			Единственное, что является новым в этой функции, - это progn. Она принимает любое количество выражений, оценивает их по порядку и возвращает значение последнего.
			</p>
			<p>
			В Common Lisp есть более простые операторы итерации для особых случаев. Например, для итерации по элементам списка вам скорее всего понадобится dolist. Вот функция, которая возвращает длину списка:
			<pre>
			(defun our-length (lst)
			  (let ((len 0))
			    (dolist (obj lst)
			      (setf len (+ len 1)))
			    len))
			</pre>
			<p>
			Здесь dolist принимает аргумент вида (выражение переменной), за которым следует тело выражений. Тело будет оценено с привязкой переменной к последовательным элементам списка, возвращенного выражением. Таким образом, цикл выше говорит: для каждого obj в lst увеличить len.
			</p>
			<p>
			Очевидной рекурсивной версией этой функции будет:
			</p>
			<pre>
			(defun our-length (lst)
			  (if (null lst)
			      0
			      (+ (our-length (cdr lst)) 1)))
			</pre>
			<p>
			Или, если список пуст, его длина равна нулю, в противном случае - это длина cdr плюс единица. Эта версия our-length чище, но поскольку она не является хвостовой рекурсивной (раздел 13.2), она не будет такой эффективной.
			</p>
			<p>
			<b>2.14 Функции как объекты</b>
			</p>
			<p>
			В Lisp функции - это обычные объекты, такие же, как символы, строки или списки. Если мы передадим имя функции в функцию function, она вернет связанный с ней объект. Как и quote, function - это специальный оператор, поэтому нам не нужно заключать аргумент в кавычки:
			</p>
			<pre>
			> (function +)
			#&ltCompiled-Function + 17BA4E&gt
			</pre>
			<p>
			Это странно выглядящее возвращаемое значение - способ отображения функции в типичной реализации Common Lisp.
			</p>
			<p>
			До сих пор мы имели дело только с объектами, которые при отображении Lisp выглядят так же, как и при вводе. Это соглашение не относится к функциям. Внутри встроенной функции, такой как +, скорее всего, будет сегмент кода машинного языка. Реализация Common Lisp может выбрать любое внешнее представление.
			</p>
			<p>
			Точно так же, как мы можем использовать ' в качестве сокращения для цитаты, мы можем использовать \#' в качестве сокращения для функции:
			</p>
			<pre>
			> #'+
			#&ltCompiled-Function + 17BA4E&gt
			</pre>
			<p>
			Эта аббревиатура известна как sharp-quote.
			</p>
			<p>
			Как и любой другой объект, мы можем передавать функции в качестве аргументов. Одной из функций, принимающих функцию в качестве аргумента, является apply. Она принимает функцию и список аргументов для нее, и возвращает результат применения функции к аргументам:
			</p>
			<pre>
			> (apply #'+ '(1 2 3))
			6
			> (+ 1 2 3)
			6
			</pre>
			<p>
			Ему можно передать любое количество аргументов, лишь бы последний из них был списком:
			</p>
			<pre>
			> (apply #'+ 1 2 '(3 4 5))
			15
			</pre>
			<p>
			Функция funcall делает то же самое, но не требует, чтобы аргументы были упакованы в список:
			</p>
			<pre>
			> (funcall #'+ 1 2 3)
			6
			</pre>
			<p>
			Макрос defun создает функцию и дает ей имя. Но функции не обязательно должны иметь имена, и нам не нужен defun для их определения. Как и большинство других объектов Lisp, мы можем ссылаться на функции буквально.
			</p>
			<p>
			Для буквального обозначения целого числа мы используем серию цифр; для буквального обозначения функции мы используем так называемое лямбда-выражение. Лямбда-выражение - это список, содержащий символ lambda, за которым следует список параметров, а затем тело из нуля или более выражений.
			</p>
			<p>
			Вот выражение лямбда, представляющее функцию, которая принимает два числа и возвращает их сумму:
			</p>
			<pre>
			(lambda (x y) 
			  (+ x y))
			</pre>
			<p>
			Список (x y) - это список параметров, а после него идет тело функции.
			</p>
			<p>
			Лямбда-выражение можно рассматривать как имя функции. Как и имя обычной функции, лямбда-выражение может быть первым элементом вызова функции,
			</p>
			<pre>
			> ((lambda (x) (+ x 100)) 1)
			101
			</pre>
			<p>
			и, прикрепив к лямбда-выражению кавычки, мы получим соответствующую функцию,
			</p>
			<pre>
			> (funcall #'(lambda (x) (+ x 100))
			           1)
			101
			</pre>
			<p>
			Кроме всего прочего, эта нотация позволяет нам использовать функции, не называя их.
			</p>
			<p>
			-----------------------------------------------------------------
			</p>
			<p>			
			<b>Что такое лямбда?</b>
			</p>
			<p>
			Лямбда в выражении лямбда не является оператором. Это просто символ. [3] В ранних диалектах Lisp он имел определенное назначение: функции представлялись внутри как списки, и единственным способом отличить функцию от обычного списка было проверить, является ли первый элемент символом лямбды.
			</p>
			<p>
			В Common Lisp вы можете выражать функции в виде списков, но внутри они представлены как отдельные объекты функций. Поэтому лямбда больше не нужна. Нет никакого несоответствия в требовании, чтобы функции обозначались как
			</p>
			<pre>
			((x) (+ x 100))
			</pre>
			<p>
			вместо
			</p>
			<pre>
			(lambda (x) (+ x 100))
			</pre>
			<p>
			но программисты Lisp привыкли начинать функции с символа лямбда, поэтому Common Lisp сохранил его ради традиции.
			</p>
			<p>
			-----------------------------------------------------------------
			</p>
			<p>
			<b>2.15 Типы</b>
			</p>
			<p>
			В Lisp необычайно гибкий подход к типам. Во многих языках переменные - это то, что имеет типы, и вы не можете использовать переменную, не указав ее тип. В Common Lisp типы имеют значения, а не переменные. Можно представить, что к каждому объекту прикреплена метка, определяющая его тип. Такой подход называется явной типизацией. Вам не нужно объявлять типы переменных, потому что любая переменная может содержать объекты любого типа.
			</p>
			<p>
			Хотя объявление типов никогда не является обязательным, вы можете захотеть сделать его из соображений эффективности. Объявление типов обсуждается в разделе 13.3.
			</p>
			<p>
			Встроенные типы Common Lisp образуют иерархию подтипов и супертипов. Объект всегда имеет более одного типа. Например, число 27 имеет типы fixnum, integer, rational, real, number, atom и t, в порядке возрастания общности. (Числовые типы рассматриваются в главе 9.) Тип t является супертипом всех типов, поэтому все имеет тип t.
			</p>
			<p>
			Функция typep принимает объект и спецификатор типа и возвращает true, если объект относится к данному типу:
			</p>
			<pre>
			> (typep 27 'integer)
			T
			</pre>
			<p>
			Мы будем упоминать различные встроенные типы по мере их появления.
			</p>
			<p>
			<b>2.16 Забегая вперед</b>
			</p>
			<p>
			В этой главе мы едва коснулись поверхности Lisp. И все же портрет очень необычного языка начинает вырисовываться. Начнем с того, что язык имеет единый синтаксис для выражения всей структуры программы. Этот синтаксис основан на списке, который является разновидностью объекта Lisp. Функции, которые сами по себе являются объектами Lisp.
			сами по себе, могут быть выражены в виде списков. А сам Lisp - это программа на Lisp, состоящая почти полностью из функций Lisp, ничем не отличающихся от тех, которые вы можете определить сами.
			</p>
			<p>
			Не волнуйтесь, если связи между всеми этими идеями не совсем понятны. Lisp вводит так много новых понятий, что потребуется некоторое время, чтобы привыкнуть ко всем новым вещам, которые вы можете делать с его помощью. По крайней мере, одно должно быть ясно: здесь есть несколько поразительно элегантных идей.
			</p>
			<p>
			Ричард Гэбриэл однажды полушутливо назвал C языком для написания Unix. [4] Точно так же мы могли бы описать Lisp как язык для написания Lisp. Но это утверждение другого рода. Язык, который может быть написан сам по себе, принципиально отличается от языка, пригодного для написания некоторого определенного класса приложений. Он открывает новый способ программирования: вы можете не только написать свою программу на языке, но и усовершенствовать язык в соответствии со своей программой. Если вы хотите понять суть программирования на Lisp, эта идея - хорошее место для начала.
			</p>
			<p>
			<b>Резюме</b> 
			</p>
			<ul>
				<li>
			1. Lisp - это интерактивный язык. Если вы введете выражение на верхнем уровне, Lisp отобразит его значение.
				</li>
				<li>
			2. Программы на Lisp состоят из выражений. Выражение может быть атомом или списком оператора, за которым следует ноль или более аргументов. Префиксный синтаксис означает, что операторы могут принимать любое количество аргументов.
				</li>
				<li>
			3. Правило оценки для вызовов функций Common Lisp: оценивать аргументы слева направо и передавать их в функцию, обозначенную оператором. Оператор кавычек имеет свое собственное правило оценки, которое заключается в возврате аргумента без изменений.
				</li>
				<li>
			4. Наряду с обычными типами данных, в Lisp есть символы и списки. Поскольку программы на Lisp выражаются в виде списков, легко писать программы, которые пишут программы.
				</li>
				<li>
			5. Три основные функции списка: cons, которая строит список; car, которая возвращает первый элемент; и cdr, которая возвращает все после первого элемента.
				</li>
				<li>
			6. В языке Common Lisp t означает true, а nil - false. В логическом контексте все, кроме nil, считается истинным. Основным условным оператором является if. Операторы and и or похожи на условные.
				</li>
				<li>
			7. Lisp состоит в основном из функций. Вы можете определять новые функции с помощью функции defun.
				</li>
				<li>
			8. Функция, которая вызывает сама себя, является рекурсивной. Рекурсивную функцию следует рассматривать как процесс, а не как машину.
				</li>
				<li>
			9. Круглые скобки не являются проблемой, потому что программисты читают и пишут Lisp с отступами.
				</li>
				<li>
			10. Основными функциями ввода-вывода являются read, которая включает полный синтаксический анализатор Lisp, и format, которая генерирует вывод на основе шаблонов.
				</li>
				<li>
			11. Вы можете создавать новые локальные переменные с помощью let, а глобальные переменные - с помощью defparameter.
				</li>
				<li>
			12. Оператором присваивания является setf. Его первым аргументом может быть выражение.
				</li>
				<li>
			13. Функциональное программирование, то есть избегание побочных эффектов, является доминирующей парадигмой в Lisp.
				</li>
				<li>
			14. Основной оператор итерации - do.
				</li>
				<li>
			15. Функции - это обычные объекты Lisp. Они могут передаваться в качестве аргументов и обозначаться лямбда-выражениями.
				</li>
				<li>
			16. В Lisp значения имеют типы, а не переменные.
				</li>
			</ul>
			<p>
			<b>Проблемы</b>
			</p>
			<ul>
				<li>
			1. Опишите, что происходит при оценке следующих выражений:
			<pre>
				a. (+ (- 5 1) (+ 3 7))

				b. (list 1 (+ 2 3))

				c. (if (listp 1) (+ 1 2) (+ 3 4))

				d. (list (and (listp 3) t) (+ 1 2))
			</pre>
				</li>
				<li>			
			2. Приведите три различных выражения, которые возвращают (a b c).
				</li>
				<li>
			3. Используя выражения car и cdr, определите функцию, возвращающую четвертый элемент списка.
				</li>
				<li>
			4. Определите функцию, которая принимает два аргумента и возвращает больший из них.
				</li>
				<li>
			5. Что делают эти функции?
			<pre>
				a. (defun enigma (x)
			         (and (not (null x))
			              (or (null (car x))
			                  (enigma (cdr x)))))

			    b. (defun mystery (x y)
			         (if (null y)
			             nil
			             (if (eql (car y) x)
			                 0
			                 (let ((z (mystery x (cdr y))))
			                   (and z (+ z 1))))))
			</pre>
				</li>
				<li>
			6. Что может стоять на месте x в каждом из следующих обменов?
			<pre>
				a. > (car (x (cdr '(a (b c) d))))
				   B

				b. > (x 13 (/ 1 0))
				   13

				c. > (x #'list 1 nil)
				   (1)
			</pre>
				</li>
				<li>
			7. Используя только операторы, введенные в этой главе, определите функцию, которая принимает в качестве аргумента список и возвращает true, если один из ее элементов является списком.
				</li>
				<li>
			8. Дайте итеративное и рекурсивное определения функции, которая
			<pre>
			    a. принимает целое положительное число и печатает столько точек.

			    b. берет список и возвращает количество раз, когда в нем встречается символ a.
			</pre>
				</li>
				<li>			
			9. Друг пытается написать функцию, которая возвращает сумму всех ненулевых элементов в списке. Он написал две версии этой функции, но ни одна из них не работает. Объясните, что не так в каждой из них, и дайте правильный вариант:
			<pre>
				a. (defun summit (lst)
			        (remove nil lst)
			        (apply #'+ lst))
			   
			    b. (defun summit (lst)
			        (let ((x (car lst)))
			          (if (null x)
			              (summit (cdr lst))
			              (+ x (summit (cdr lst))))))		
			</pre>
				</li>
			</ul>
			<br>
			<p>			
			Примечания
			</p>
			<p>
			[1] Имена car и cdr происходят от внутреннего представления списков в первой реализации Lisp: car означало "содержимое адресной части регистра", а cdr - "содержимое декрементной части регистра".
			</p>
			<p>
			[2] Читатели, у которых возникли проблемы с концепцией рекурсии, могут проконсультироваться с одним из следующих авторов:
			</p>
			<p>
			Touretzky, David S. Common Lisp: A Gentle Introduction to Symbolic Computation. Benjamin/Cummings, Redwood City (CA), 1990, глава 8.
			</p>
			<p>
			Фридман, Дэниел П. и Матиас Феллейзен. Маленький лиспер. MIT Press, Cambridge, 1987.
			</p>
			<p>
			[3] В Ansi Common Lisp также есть макрос лямбда, который позволяет писать (лямбда (x) x) для #'(лямбда (x) x). Поскольку использование этого макроса нарушает симметрию между лямбда-выражениями и символическими именами функций (где все равно приходится использовать sharp-quote), то в лучшем случае это дает некое подобие элегантности.
			</p>
			<p>
			[4] Gabriel, Richard P. Lisp: Хорошие новости, плохие новости, как выиграть по-крупному. AI Expert, июнь 1991, с. 34.
			</p>
			<p>
			-------------------------------------------------------------------
			</p>
			<p>
			Доступно на: <a href="http://www.amazon.com/exec/obidos/ASIN/0133708756">http://www.amazon.com/exec/obidos/ASIN/0133708756</a>
			</p>
			<footer>
				<nav>
				<div style="margin: 0 auto; width: 200px; font-size: 15px">
					<span>
							<a href="/">Главная</a>
							<a href="/paulgraham">Пол Грэм</a>
							<a href="/sivers">Дерек Сиверc</a>
							<a href="/donation">Донаты</a>
					</span>
				</div>
				</nav>
				<p>Будь верен себе</p>
				<address>
					<p>Иван Капцов, Планета Земля, Измерение C-137</p>
				</address>
			</footer>
	</body>
</html>