<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Five Questions about Language Design</title>
	<style>body,html{margin:0;padding:0}body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;padding:32px 16px 32px;font-size:16px;line-height:1.5}@media (min-width:40em){body{font-size:20px;padding:64px 32px 64px}}@media (min-width:52em){body{font-size:24px;padding:60px 64px 128px}}footer{color:#ccc;margin-top:5em}section{max-width:864px}h1{font-size:32px;line-height:1.25;margin:.5em 0 0}@media (min-width:40em){h1{font-size:48px}}@media (min-width:52em){h1{font-size:64px}}h2{font-size:28px;line-height:1.25;margin:.5em 0 0}@media (min-width:40em){h2{font-size:42px}}@media (min-width:52em){h2{font-size:56px}}h3{font-size:16px;line-height:1.25;margin:2em 0 0}@media (min-width:40em){h3{font-size:24px}}@media (min-width:52em){h3{font-size:32px}}hr{margin:3em 0;max-width:864px;border:0;border-bottom:1px solid #f6f6f6}@media (min-width:40em){hr{margin:2em 0}}.logo{display:inline-block;vertical-align:-1px;margin-left:.2em}a{text-decoration:none;color:#0075ff;background:0 100%/100% 1px repeat-x;background-image:linear-gradient(rgba(0,117,255,.13),rgba(0,117,255,.13))}@media (min-width:40em){a{background-size:100% 2px}}a:hover{background-image:linear-gradient(rgba(0,117,255,1),rgba(0,117,255,1))}.logo-link{white-space:nowrap}ul{margin-top:1em;padding-left:2em;list-style:none}ul li+li{margin-top:.25em}.buzzwords{color:#aaa;font-size:.8em}address{font-size:.7em;font-style:normal}</style></head>
	<body>
		<section>
			<h1>Five Questions about Language Design</h1>
			<div>
					<span>
							<a href="http://www.paulgraham.com/langdes.html">Оригинал</a>
							<a href="https://habr.com/ru/post/477366/">Перевод</a>
					</span>
				</div>
		</section>
			<p>
			Май 2001
			</p>
			<p>
			(Это записи, которые я сделал для групповой дискуссии по проектированию языков программирования в Массачусетском технологическом институте 10 мая 2001).
		</p>
			<p>
			<b>Руководящая философия</b>
			</p>
			<p>
			<b>1. Языки программирования для людей</b>
			</p>
			<p>
			Языки программирования это то, как люди говорят с компьютерами. Компьютер будет рад поговорить на любом языке, который не будет двусмысленным. Причина почему у нас есть высокоуровневые языки — потому что люди не могут справиться с машинным языком. Суть языков программирования в том, чтобы предотвратить наш бедный хрупкий человеческий мозг от перегрузки массой деталей.
			</p>
			<p>
			Архитекторы знают, что некоторые проблемы проектирования более приземлённые, чем другие. Одни из самых ясных и абстрактных проблем проектирования это проектирование мостов. В этом случае ваша работа в том, чтобы охватить требуемое расстояние как можно меньшим количеством материала. На другом конце спектра — проектирование стульев. Проектировщики стульев должны тратить своё время на размышления о человеческих задницах.
			</p>
			<p>
			Разработка софта имеет схожее различие. Проектирование алгоритмов для маршрутизации данных через сеть — хорошая, абстрактная проблема, как проектирование мостов. Тогда как проектирование языков программирования подобно проектированию стульев: нужно справляться с человеческими слабостями.
			</p>
			<p>
			Большинству из нас тяжело это осознавать. Проектирование элегантных математических систем звучит гораздо более привлекательно для большинства из нас, чем потворство человеческим слабостям. Роль математической элегантности в том, что некоторая степень элегантности делает программы проще для понимания. Но элегантностью всё не ограничивается.
			</p>
			<p>
			И когда я говорю, что языки должны быть спроектированы, чтобы учитывать человеческие слабости, я не имею ввиду что языки должны быть спроектированы для плохих программистов. На самом деле вы должны проектировать софт для <a href="http://www.paulgraham.com/design.html">лучших программистов</a>, но даже лучшие программисты имеют свой предел. Я не думаю, что хоть кому-нибудь понравится программировать на языке, где все переменные обозначались бы буквой «x» с целочисленными индексами.
			</p>
			<p>
			<b>2. Проектируйте для себя и для своих друзей</b>
			</p>
			<p>
			Если вы посмотрите на историю языков программирования, большинство из самых лучших языков были спроектированы для использования своими же авторами, а большинство из худших — спроектированы для других людей.
			</p>
			<p>
			Когда языки проектируются для других людей, то это всегда какая-то конкретная группа людей: люди не такие умные, как создатели языка. Так вы получаете язык, который говорит с вами снисходительно. Cobol — самый яркий пример, но большинство языков пронизаны этим духом.
			</p>
			<p>
			Это не имеет ничего общего с тем, насколько высокоуровневым является язык. C — достаточно низкоуровневый, но он был создан для использования его авторами, вот почему хакеры любят его.
			</p>
			<p>
			Аргумент в пользу проектирования языков для плохих программистов в том, что плохих программистов больше, чем хороших. Пожалуй это так. Но это небольшое количество хороших программистов пишет непропорционально больше софта.
			</p>
			<p>
			Меня интересует вопрос, как создать язык, который понравится самым лучшим хакерам? Мне кажется этот вопрос идентичен вопросу, как создать хороший язык программирования?, но даже если это не так, то по крайней мере это интересный вопрос.
			</p>
			<p>
			<b>3. Дайте программисту столько контроля, сколько возможно</b>
			</p>
			<p>
			Многие языки (особенно те, которые созданы для других людей) ведут себя как няньки: они стараются предостеречь вас от вещей, которые, по их мнению, будут вам не полезны. Я придерживаюсь противоположного мнения: дайте программисту столько контроля сколько можете.
			</p>
			<p>
			Когда я впервые изучал Lisp, больше всего мне понравилось то, что мы разговаривали на равных. В других языках, которые я к тому моменту изучил, был язык, а была моя программа на этом языке, и они существовали довольно отдельно. Но в Lisp'е функции и макросы, которые я написал, были такими же на которых был написан сам язык. Я мог переписать сам язык, если бы захотел. Он имел такую же привлекательность, что и софт с открытым кодом.
			</p>
			<p>
			<b>4. Краткость — сестра таланта</b>
			</p>
			<p>
			Краткость недооценена и даже презирается. Но если вы загляните в сердца хакеров, вы увидите, что они очень любят краткость. Сколько раз вы слышали, как хакеры с любовью говорят о том, что, скажем, в APL они могут делать удивительные вещи с помощью всего лишь пары строк кода? Я полагаю, что по-настоящему умные люди на самом деле любят обращать внимание на это.
			</p>
			<p>
			Я полагаю, что почти всё, что позволяет сделать программы короче — хорошо. Должно быть множество библиотечных функций, всё, что может быть неявным — должно таким быть; синтаксис должен быть в большей степени кратким; даже имена сущностей должны быть короткими.
			</p>
			<p>
			И не только программы должны быть короткими. Мануалы тоже должны быть короткими. Добрая часть мануалов наполнена разъяснениями, оговорками, предупреждениями и особыми случаями. Если вам потребуется сократить мануал, лучший вариант это исправить язык, который требует так много объяснений.
			</p>
			<p>
			<b>5. Признайте, что такое хакерство</b>
			</p>
			<p>
			Многим людям хотелось бы, чтобы хакерство было бы математикой или, хотя бы, чем-то похожим на естественные науки. Я думаю, что хакерство больше похоже на архитектуру. Архитектура связана с физикой, в том плане, что архитектору нужно проектировать здание, которое не упадёт, но настоящая цель архитектора в том, чтобы создать великое здание, а не сделать открытия в области статики.
			</p>
			<p>
			Что хакеры любят, так это создавать великие программы. И я думаю, что, по крайней мере, в наших собственных мыслях, мы должны помнить, что писать замечательные программы — это замечательно, даже когда эта работа нелегко переводится в обычную интеллектуальную валюту научных работ. С интеллектуальной точки зрения, не менее важно как разрабатывать язык, который полюбят программисты, так и создавать ужасный, воплощающий идею, о которой вы можете опубликовать статью.
			</p>
			<br>
			<p>
			<b>Открытые проблемы</b>
			</p>
			<p>
			<b>1. Как организовать большие библиотеки?</b>
			</p>
			<p>
			Библиотеки становятся важной частью языков программирования. Они становятся настолько большими, что это может быть опасно. Если требуется больше времени, чтобы найти функцию в библиотеке, которая делает то, что вам нужно, чем написать эту функцию самому, то весь код не делает ничего, кроме утолщения вашего мануала. (Руководства Symbolics были тому примером.) Так что нам придётся решить проблему с организацией библиотек. В идеале спроектировать их так, чтобы программист мог бы догадаться, какая функция библиотеки подойдёт.
			</p>
			<p>
			<b>2. Люди действительно напуганы префиксным синтаксисом?</b>
			</p>
			<p>
			Это открытая проблема в том смысле, что я думал над ней несколько лет и всё ещё не знаю ответ. Префиксный синтаксис кажется мне абсолютно естественным, возможно кроме использования его в математике. Но может так, что большая часть непопулярности Lisp'ов просто из-за незнакомого синтаксиса… Стоит ли что-то с этим делать, если это правда, это другой вопрос.
			</p>
			<p>
			<b>3. Что вам нужно для серверного софта?</b>
			</p>
			<p>
			Я думаю, что большинство приложений, которые будут написаны в следующие двадцать лет будут веб-приложениями, в том смысле, что программы будут расположены на сервере и будут общаться с вами через веб-браузер. И чтобы написать такие приложения нам нужны новые штуки.
			</p>
			<p>
			Одна из таких вещей это поддержка нового способа выпуска серверных приложений. Вместо одного или двух больших релизов в год, как десктопный софт, серверный софт будет выпускаться серией мелких изменений. У вас может быть пять или десять релизов в день. И у всех всегда будет последняя версия.
			</p>
			<p>
			Вы знаете как проектировать программы, чтобы они были поддерживаемыми? Серверный софт должен быть спроектирован способным к изменениям. У вас должна быть возможность изменять его легко, или хотя бы знать что значит мелкое изменение и что является важным.
			</p>
			<p>
			Ещё одна вещь, которая может быть полезной в серверном софте, это, внезапно, непрерывность поставки. В веб-приложении вы можете использовать что-то вроде CPS, чтобы получить эффект от <a href="http://www.paulgraham.com/lwba.html">подпрограмм</a> в stateless мире веб-сессий. Может иметь непрерывность поставки стоит того, если эта возможность не будет слишком дорогой.
			</p>
			<p>
			<b>4. Какие новые абстракции осталось открыть?</b>
			</p>
			<p>
			Я не уверен, насколько разумна такая надежда, но лично мне бы очень хотелось открыть новую абстракцию — нечто такое, что могло бы иметь такое же большое значение, как функции первого класса или рекурсия или хотя бы параметры по умолчанию. Может это невыполнимая мечта. Такие вещи часто не открывают. Но я не теряю надежду.
			</p>
			<br>
			<p>
			<b>Малоизвестные секреты</b>
			</p>
			<p>
			<b>1. Вы можете использовать любой язык, какой пожелаете</b>
			</p>
			<p>
			Раньше под созданием приложений подразумевалось создание десктопного софта. А в десктопном софте есть большой уклон в сторону написания приложений на том же языке, что и операционная система. Так десять лет назад, написание софта в целом означало написание софта на C. В конце концов традиция эволюционировала: приложения не должны быть написаны на необычных языках. И эта традиция так долго развивалась, что нетехнические люди, вроде менеджеров и венчурных капиталистов, тоже это выучили.
			</p>
			<p>
			Серверный софт уничтожает эту модель полностью. С серверным софтом вы можете взять любой язык, какой пожелаете. Почти никто ещё этого не понимает (особенно менеджеры и венчурные капиталисты). Но некоторые хакеры понимают это, вот почему мы слышали про такие indy-языки как Perl и Python. Мы не слышим про Perl и Python, потому что люди используют их для написания приложений для Windows.
			</p>
			<p>
			Что это означает для нас, людей заинтересованных в проектировании языков программирования, что есть потенциальная аудитория для нашей работы.
			</p>
			<p>
			<b>2. Скорость приходит от профайлеров</b>
			</p>
			<p>
			Разработчики языка или, по крайней мере, его реализаторы любят писать компиляторы, которые генерируют быстрый код. Но я думаю, что не это делает языки быстрыми для пользователей. Кнут давно заметил, что скорость зависит всего от нескольких узких мест. И любой, кто пытался ускорить программу знает, что вы не сможете угадать, где узкое место. Профайлер вот ответ.
			</p>
			<p>
			Разработчики языка решают не ту проблему. Пользователям не нужно, чтобы бенчмарки работали быстро. Им нужен язык, который может показать какие части их программы должны быть переписаны. В этот момент скорость нужна на практике. Так может будет лучше, если реализаторы языка потратят половину времени, которое они тратят на оптимизацию компилятора, и потратят его на написание хорошего профайлера.
			</p>
			<p>
			<b>3. Вам нужно приложение, которое заставляет ваш язык развиваться</b>
			</p>
			<p>
			Может это не истина в последней инстанции, но кажется лучшие языки развивались вместе с приложениями, в которых их использовали. C был написан людьми, которым нужно было системное программирование. Lisp был разработан отчасти для символьного дифференцирования, Маккарти так не терпелось начать, что он начал писать программы дифференцирования даже в первом документе о Lisp'е в 1960 году.
			</p>
			<p>
			Это особенно хорошо, если ваше приложение решает некоторые новые проблемы. Это подталкивает ваш язык иметь новые возможности, которые нужны программистам. Лично мне интересно писать язык, который будет хорош для серверных приложений.
			</p>
			<p>
			[Во время дискуссии Гай Стил также высказал эту мысль, добавив, что приложение не должно состоять из написания компилятора для вашего языка, если только ваш язык не предназначен для написания компиляторов.]
			</p>
			<p>
			<b>4. Язык должен быть подходящим для написания одноразовых программ.</b>
			</p>
			<p>
			Вы знаете, что значит одноразовая программа: это когда вам нужно быстро решить какую-то ограниченную задачу. Я полагаю, что если вы посмотрите вокруг, то обнаружите множество серьёзных программ, которые начинались как одноразовые. Я не удивлюсь, если большинство программ начинались как одноразовые. Таким образом, если вы хотите создать язык, который будет подходящим для написания софта в целом, то он должен и подходить для написания одноразовых программ, потому что это начальная стадия многих программ.
			</p>
			<p>
			<b>5. Синтаксис связан с семантикой</b>
			</p>
			<p>
			Традиционно считается, что синтаксис и семантика — вещи сильно отличающиеся. Может это прозвучит шокирующе, но это не так. Я думаю, что то, что вы хотите получить в вашей программе связано с тем, как вы это выражаете.
			</p>
			<p>
			Недавно я говорил с Робертом Моррисом, и он заметил, что перегрузка операторов это большой плюс в победу языков с инфиксным синтаксисом. В языках с префиксным синтаксисом любая функция, которую вы определяете фактически является оператором. Если вы хотите сложить новый тип числа, который вы выдумали, вы можете просто определить новую функцию для его добавления. Если вы сделаете так в языке с инфиксным синтаксисом, вы увидите, что между использованием перегруженного оператора и вызовом функции существует большая разница.
			</p>
			<br>
			<p>
			<b>Идеи, которые со временем возвращаются</b>
			</p>
			<p>
			<b>1. Новые языки программирования</b>
			</p>
			<p>
			Оглядываясь в 1970-е, было модно разрабатывать новые языки программирования. Сейчас это не так. Но я полагаю, что серверный софт снова вернёт моду на создание новых языков. С серверным софтом вы можете использовать любой язык, какой пожелаете, так если кто-нибудь создаст язык, который будет казаться лучше остальных, то будут люди, которые решатся его использовать.
			</p>
			<p>
			<b>2. Разделение времени</b>
			</p>
			<p>
			Ричард Келси подал эту идею, время которой снова пришло, и я полностью её поддерживаю. Моё предположение (и Microsoft тоже) многие вычисления переместятся с десктопа на удалённые сервера. Другими словами, разделение времени вернулось. Я думаю понадобится поддержка этого на уровне языка. Например, Ричард и Джонатан Ривз проделали много работы для внедрения планирования процесса в Scheme 48.
			</p>
			<p>
			<b>3. Эффективность</b>
			</p>
			<p>
			Недавно казалось, что компьютеры уже достаточно быстры. Всё больше и больше мы слышим про байт-код, что по крайней мере, для меня означает, что у нас есть мощность в запасе. Но я думаю, что с серверным софтом, у нас её нет. Кто-то должен будет заплатить за серверы, на которых работает софт, и число пользователей, которых сервер может выдержать в расчёте на одну машину, будет делителем их капитальных затрат.
			</p>
			<p>
			Думаю, что эффективность будет иметь значение, по крайней мере в узких местах вычислений. Особенно важным это будет для операций ввода-вывода, потому что серверные приложения производят множество таких операций.
			</p>
			<p>
			В конце концов может оказаться, что байт-код это не выход. Sun и Microsoft в данный момент похоже сражаются лицом к лицу на байт-код поле. Но они это делают, потому что байт-код это удобное место для встраивания себя в процесс, а не потому что байт-код сам по себе хорошая идея. Может оказаться, что вся эта битва пройдёт незамеченной. Было бы забавно.
			</p>
			<br>
			<p>
			<b>Западни и ловушки</b>
			</p>
			<p>
			<b>1. Клиенты</b>
			</p>
			<p>
			Это только предположение, но оно в том, что выиграют только те приложения, которые будут полностью серверными. Проектируя софт, который работает на предположении, что у каждого будет ваш клиент, похоже на создание общества основанного на предположении, что все будут честными. Это было бы определённо удобно, но вам придётся допустить, что этого никогда не будет.
			</p>
			<p>
			Я думаю будет быстрое увеличение девайсов с доступом в веб, и можно предположить, что они будут поддерживать базовый html и формы. У вас есть браузер на телефоне? Будет ли телефон в вашем PalmPilot'e? У вашего blackberry будет больший экран? Будет ли у вас возможность выйти в интернет со своего gameboy? С ваших часов? Я не знаю. И мне не придётся это узнать, если я сделаю ставку, что всё будет на сервере. Просто гораздо надёжнее иметь все <a href="http://www.paulgraham.com/road.html">мозги на сервере</a>.
			</p>
			<p>
			<b>2. Объектно-ориентированное программирование</b>
			</p>
			<p>
			Я понимаю, что это противоречивое утверждение, но я не считаю, что ООП это что-то важное. Я думаю, что это подходящая парадигма для конкретных приложений, которым нужны специфические структуры данных, вроде оконных систем, симуляций, САПР-систем. Но я не понимаю, почему она должна быть подходящей для всех программ.
			</p>
			<p>
			Я думаю, что люди в больших компаниях любят ООП, отчасти, потому что оно даёт многое из того, что выглядит как работа. То, что, естественно, может быть представлено как, скажем, список целых чисел, теперь может быть представлено как класс со всеми видами строительных лесов, с шумом и суетой.
			</p>
			<p>
			Другая привлекательная черта ООП в том, что методы дают вам некий эффект функций первого класса. Но это не новость для программистов на Lisp'ах. Когда у вас есть настоящие функции первого класса, вы можете просто использовать их любым способом, который соответствует поставленной задаче вместо того, чтобы проталкивать всё в шаблон из классов и методов,.
			</p>
			<p>
			Я думаю, что это означает для языкового дизайна, что вы не должны слишком глубоко встраивать ООП в него. Может ответ в том, чтобы предлагать более общие, основополагающие вещи, и позволить людям проектировать любые объектные системы в виде библиотек.
			</p>
			<p>
			<b>3. Проектирование комитетом</b>
			</p>
			<p>
			Если ваш язык проектирует комитет, то вы в западне, и не только по причинам, которые всем известны. Всем известно, что комитеты имеют тенденцию создавать комковатый, непоследовательный дизайн языка. Но я думаю, что большая опасность в том, что они не берут на себя риски. Когда во главе один человек, то он берет риски, которые комитет никогда не согласится взять на себя.
			</p>
			<p>
			Нужно ли рисковать, чтобы создать хороший язык? Многие люди могут подозревать, что проектирование языка — это то, где вы должны держаться довольно близко к традиционной мудрости. Могу поспорить, что это не так. Во всем остальном, что делают люди, вознаграждение пропорционально риску. Так почему же в проектировании языков должно быть по-другому?
			</p>
			<footer>
				<nav>
				<div style="margin: 0 auto; width: 200px; font-size: 15px">
					<span>
							<a href="/">Главная</a>
							<a href="/paulgraham">Пол Грэм</a>
							<a href="/sivers">Дерек Сиверc</a>
							<a href="/donation">Донаты</a>
					</span>
				</div>
				</nav>
				<p>Будь верен себе</p>
				<address>
					<p>Иван Капцов, Планета Земля, Измерение C-137</p>
				</address>
			</footer>
	</body>
</html>